#include <iostream>
#include <vector>
#include <cmath>
#include <limits>

#ifdef _WIN32
#include <windows.h>
#endif

// Definición de colores ANSI para la terminal
#define RESET "\033[0m"
#define BLANCO "\033[97m"
#define NEGRO "\033[90m"
#define TABLERO_COLOR "\033[37m"
#define RESALTAR "\033[93m"
#define LIMPIAR "\033[2J\033[1;1H"

// Clase que representa una pieza individual del juego
class Pieza {
private:
    char color;        // 'B' para blancas, 'N' para negras
    bool esDama;       // Indica si la pieza ha sido coronada
    int fila;          // Posición actual en fila
    int columna;       // Posición actual en columna

public:
    // Constructor: inicializa una pieza con color y posición
    Pieza(char c, int f, int col) : color(c), esDama(false), fila(f), columna(col) {}

    // Retorna el color de la pieza
    char getColor() const {
        return color;
    }

    // Verifica si la pieza es una Dama
    bool getDama() const {
        return esDama;
    }

    // Convierte la pieza en Dama (coronación)
    void coronar() {
        esDama = true;
    }

    // Obtiene la fila actual de la pieza
    int getFila() const {
        return fila;
    }

    // Obtiene la columna actual de la pieza
    int getColumna() const {
        return columna;
    }

    // Actualiza la posición de la pieza
    void setPos(int f, int col) {
        fila = f;
        columna = col;
    }
};
// Clase que representa el tablero de juego 10x10
class Tablero {
private:
    std::vector<std::vector<Pieza*>> casillas;  // Matriz de punteros a piezas
    int tamano;                                   // Tamaño del tablero (10x10)

public:
    // Constructor: inicializa el tablero vacío
    Tablero() : tamano(10) {
        casillas.resize(tamano, std::vector<Pieza*>(tamano, nullptr));
    }
    
    // Destructor: libera memoria de todas las piezas
    ~Tablero() {
        for(int i = 0; i < tamano; i++) {
            for(int j = 0; j < tamano; j++) {
                if(casillas[i][j] != nullptr) {
                    delete casillas[i][j];
                }
            }
        }
    }
// Coloca las 20 piezas iniciales de cada jugador en el tablero
    void inicializar() {
        // Colocar piezas blancas en las primeras 4 filas (solo casillas oscuras)
        for(int i = 0; i < 4; i++) {
            for(int j = 0; j < tamano; j++) {
                if((i + j) % 2 == 1) {
                    casillas[i][j] = new Pieza('B', i, j);
                }
            }
        }

        // Colocar piezas negras en las últimas 4 filas (solo casillas oscuras)
        for(int i = 6; i < tamano; i++) {
            for(int j = 0; j < tamano; j++) {
                if((i + j) % 2 == 1) {
                    casillas[i][j] = new Pieza('N', i, j);
                }
            }
        }
    }

    // Muestra el tablero en la consola con colores y símbolos
    void mostrar() const {
        std::cout << LIMPIAR;
        std::cout << RESALTAR << "\n      DAMAS INTERNACIONALES 10x10" << RESET << "\n\n";
       // Imprimir números de columna
        std::cout << "    ";
        for(int i = 0; i < tamano; i++) {
            std::cout << i << " ";
        }
        std::cout << "\n";
        
        // Imprimir cada fila del tablero
        for(int i = 0; i < tamano; i++) {
            std::cout << i << "   ";
            for(int j = 0; j < tamano; j++) {
                if(casillas[i][j] != nullptr) {
                    // Mostrar piezas blancas
                    if(casillas[i][j]->getColor() == 'B') {
                        if(casillas[i][j]->getDama()) {
                            std::cout << BLANCO << "◆ " << RESET;  // Dama blanca
                        } else {
                            std::cout << BLANCO << "● " << RESET;  // Pieza blanca normal
                        }
                    } else {
                        // Mostrar piezas negras
                        if(casillas[i][j]->getDama()) {
                            std::cout << NEGRO << "◆ " << RESET;  // Dama negra
                        } else {
                            std::cout << NEGRO << "● " << RESET;  // Pieza negra normal
                        }
                    }
                } else {
                    // Mostrar casillas vacías
                    if((i + j) % 2 == 1) {
                        std::cout << TABLERO_COLOR << "□ " << RESET;  // Casilla oscura jugable
                    } else {
                        std::cout << TABLERO_COLOR << "· " << RESET;  // Casilla clara no jugable
                    }
                }
            }
            std::cout << "\n";
        }
        std::cout << "\n";
    }

// Obtiene la pieza en una posición específica (nullptr si está vacía)
    Pieza* obtenerPieza(int f, int col) const {
        if(dentroTablero(f, col)) {
            return casillas[f][col];
        }
        return nullptr;
    }

    // Mueve una pieza de una posición a otra y verifica coronación
    void moverPieza(int f1, int c1, int f2, int c2) {
        if(casillas[f1][c1] != nullptr) {
            casillas[f2][c2] = casillas[f1][c1];
            casillas[f1][c1] = nullptr;
            casillas[f2][c2]->setPos(f2, c2);

            // Coronar si llega a la última fila del oponente
            if(casillas[f2][c2]->getColor() == 'B' && f2 == tamano - 1) {
                casillas[f2][c2]->coronar();
            } else if(casillas[f2][c2]->getColor() == 'N' && f2 == 0) {
                casillas[f2][c2]->coronar();
            }
        }
    }

    // Elimina una pieza del tablero (usada en capturas)
    void eliminarPieza(int f, int c) {
        if(casillas[f][c] != nullptr) {
            delete casillas[f][c];
            casillas[f][c] = nullptr;
        }
    }

    // Verifica si una casilla está vacía
    bool casillaVacia(int f, int c) const {
        if(dentroTablero(f, c)) {
            return casillas[f][c] == nullptr;
        }
        return false;
    }
   // Verifica si una posición está dentro de los límites del tablero
    bool dentroTablero(int f, int c) const {
        return f >= 0 && f < tamano && c >= 0 && c < tamano;
    }
    
    // Retorna el tamaño del tablero
    int getTamano() const {
        return tamano;
    }
};

// Clase que representa a un jugador
class Jugador {
private:
    char color;              // Color del jugador ('B' o 'N')
    int piezasRestantes;     // Cantidad de piezas que aún tiene en el tablero

public:
    // Constructor: inicializa jugador con 20 piezas
    Jugador(char c) : color(c), piezasRestantes(20) {}
    
    // Obtiene el color del jugador
    char getColor() const {
        return color;
    }
    
    // Obtiene la cantidad de piezas restantes
    int getPiezasRestantes() const {
        return piezasRestantes;
    }
    
    // Reduce en 1 la cantidad de piezas (cuando es capturada)
    void decrementarPiezas() {
        if(piezasRestantes > 0) {
            piezasRestantes--;
        }
    }
    
    // Establece manualmente la cantidad de piezas
    void setPiezasRestantes(int p) {
        piezasRestantes = p;
    }
};

// Estructura para almacenar información de un movimiento
struct Movimiento {
    int filaOrigen;
    int colOrigen;
    int filaDestino;
    int colDestino;
    bool esCaptura;      // Indica si el movimiento captura una pieza
    int filaCap;         // Fila de la pieza capturada
    int colCap;          // Columna de la pieza capturada
};

// Clase principal que controla la lógica del juego
class Juego {
private:
    Tablero tablero;         // Tablero de juego
    Jugador jugador1;        // Jugador con piezas blancas
    Jugador jugador2;        // Jugador con piezas negras
    int turnoActual;         // Contador de turnos (par=blancas, impar=negras)
    bool juegoActivo;        // Indica si el juego está en curso

public:
    // Constructor: inicializa el juego
    Juego() : jugador1('B'), jugador2('N'), turnoActual(0), juegoActivo(false) {}

    // Inicia el juego y muestra el menú principal
    void iniciar() {
        tablero.inicializar();
        mostrarMenu();
    }
